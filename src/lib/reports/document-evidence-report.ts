import { degrees, rgb, type PDFImage } from "pdf-lib";
import {
  createReportContext,
  embedImageIfPresent,
  saveReport,
  type ReportContext,
} from "@/lib/reports/engine/core";
import {
  drawKeyValueRow,
  drawMetricCards,
  drawParagraph,
  drawReportHeader,
  drawSectionHeading,
  finalizeFooters,
} from "@/lib/reports/engine/sections";
import { measureTextBlockHeight } from "@/lib/reports/engine/text";

export type DocumentEvidenceCompletion = {
  acknowledged: boolean;
  submitted_at: string | null;
  max_scroll_percent: number | null;
  time_on_page_seconds: number | null;
  active_seconds: number | null;
  ip: string | null;
  user_agent: string | null;
  recipient_name: string | null;
  recipient_email: string | null;
};

export type DocumentEvidenceReportInput = {
  reportStyleVersion: "v2";
  generatedAtIso: string;
  watermarkEnabled: boolean;
  workspaceName: string;
  brandName: string;
  brandLogoPngBytes?: Uint8Array | null;
  receiptLogoPngBytes?: Uint8Array | null;
  brandLogoWidthPx?: number | null;
  document: {
    id: string;
    title: string;
    publicId: string;
    createdAt: string;
    sha256: string | null;
    publicUrl: string;
  };
  completions: DocumentEvidenceCompletion[];
};

function fmtUtc(iso: string | null) {
  if (!iso) return "--";
  const d = new Date(iso);
  if (!Number.isFinite(d.getTime())) return "--";
  return `${UTC_FORMATTER.format(d).replace(",", "")} UTC`;
}

function fmtDuration(seconds: number | null) {
  if (seconds == null || !Number.isFinite(seconds)) return "--";
  const s = Math.max(0, Math.floor(seconds));
  const m = Math.floor(s / 60);
  const r = s % 60;
  return `${m}m ${String(r).padStart(2, "0")}s`;
}

function fmtScroll(value: number | null) {
  if (value == null || !Number.isFinite(value)) return "--";
  return `${Math.max(0, Math.min(100, Math.round(value)))}%`;
}

const UTC_FORMATTER = new Intl.DateTimeFormat("en-GB", {
  day: "2-digit",
  month: "short",
  year: "numeric",
  hour: "2-digit",
  minute: "2-digit",
  hour12: false,
  timeZone: "UTC",
});

function estimateKeyValueHeight(ctx: ReportContext, key: string, value: string, labelWidth = 180) {
  const lineHeight = Math.max(ctx.theme.lineHeight, ctx.theme.bodySize + 3.4);
  const valueWidth = Math.max(120, ctx.cursor.maxX - ctx.cursor.minX - labelWidth);
  const labelHeight = measureTextBlockHeight(ctx, {
    text: key,
    maxWidth: Math.max(72, labelWidth - 8),
    size: ctx.theme.bodySize,
    lineHeight,
    font: "bold",
  });
  const valueHeight = measureTextBlockHeight(ctx, {
    text: value,
    maxWidth: valueWidth,
    size: ctx.theme.bodySize,
    lineHeight,
  });
  return Math.max(labelHeight, valueHeight) + 6;
}

function drawWatermark(
  enabled: boolean,
  receiptLogo: PDFImage | null,
  pageWidth: number,
  pageHeight: number,
  ctx: ReportContext
) {
  if (!enabled) return;
  const baseX = pageWidth * 0.2;
  const baseY = pageHeight * 0.34;
  const angle = degrees(31);
  const text = "Generated by";
  const size = 30;

  ctx.page.drawText(text, {
    x: baseX,
    y: baseY,
    size,
    font: ctx.fonts.bold,
    color: rgb(0, 0, 0),
    opacity: 0.045,
    rotate: angle,
  });

  if (receiptLogo) {
    const h = 25;
    const scale = h / receiptLogo.height;
    const w = receiptLogo.width * scale;
    ctx.page.drawImage(receiptLogo, {
      x: baseX + ctx.fonts.bold.widthOfTextAtSize(text, size) + 13,
      y: baseY + 8,
      width: w,
      height: h,
      opacity: 0.09,
      rotate: angle,
    });
    return;
  }

  ctx.page.drawText("Receipt", {
    x: baseX + ctx.fonts.bold.widthOfTextAtSize(text, size) + 13,
    y: baseY,
    size,
    font: ctx.fonts.bold,
    color: rgb(0, 0, 0),
    opacity: 0.06,
    rotate: angle,
  });
}

export async function buildDocumentEvidencePdf(input: DocumentEvidenceReportInput) {
  let receiptLogo: PDFImage | null = null;
  const ctx = await createReportContext({
    onPageAdded: (pageCtx) => {
      drawWatermark(
        input.watermarkEnabled,
        receiptLogo,
        pageCtx.theme.pageWidth,
        pageCtx.theme.pageHeight,
        pageCtx
      );
    },
  });

  receiptLogo = await embedImageIfPresent(ctx, input.receiptLogoPngBytes);
  const workspaceLogo = await embedImageIfPresent(ctx, input.brandLogoPngBytes);

  drawWatermark(input.watermarkEnabled, receiptLogo, ctx.theme.pageWidth, ctx.theme.pageHeight, ctx);

  const generatedDate = new Date(input.generatedAtIso);
  const metadataDate = Number.isFinite(generatedDate.getTime()) ? generatedDate : new Date();
  const generatedLabel = fmtUtc(Number.isFinite(generatedDate.getTime()) ? generatedDate.toISOString() : new Date().toISOString());
  const acknowledgements = input.completions.filter((row) => row.acknowledged).length;
  const latestAck =
    [...input.completions]
      .filter((row) => row.acknowledged && row.submitted_at)
      .sort((a, b) => String(b.submitted_at).localeCompare(String(a.submitted_at)))[0]?.submitted_at ?? null;

  drawReportHeader(ctx, {
    title: input.document.title,
    subtitle: `${input.workspaceName} delivery evidence and acknowledgement record.`,
    eyebrow: "EVIDENCE RECORD",
    rightMeta: `Generated ${generatedLabel}`,
    logo: workspaceLogo ?? receiptLogo,
    logoWidthPx: input.brandLogoWidthPx,
    brandName: input.brandName,
    reportStyleVersion: input.reportStyleVersion,
  });

  drawMetricCards(
    ctx,
    [
      { label: "STATUS", value: acknowledgements > 0 ? "Acknowledged" : "Pending" },
      { label: "ACKNOWLEDGEMENTS", value: String(acknowledgements) },
      { label: "LATEST ACK", value: fmtUtc(latestAck) },
    ],
    { columns: 3 }
  );

  drawSectionHeading(ctx, "Document details", "Reference and integrity fields");
  drawKeyValueRow(ctx, "Public link", input.document.publicUrl, { valueFont: "mono" });
  drawKeyValueRow(ctx, "Record ID", input.document.id, { valueFont: "mono" });
  drawKeyValueRow(ctx, "Public ID", input.document.publicId, { valueFont: "mono" });
  drawKeyValueRow(ctx, "Created", fmtUtc(input.document.createdAt));
  drawKeyValueRow(ctx, "Document hash (SHA-256)", input.document.sha256 ?? "--", { valueFont: "mono" });
  ctx.cursor.y -= 9;

  drawSectionHeading(
    ctx,
    "Completions",
    `${input.completions.length} total submission${input.completions.length === 1 ? "" : "s"}`
  );

  const completions = [...input.completions].sort(
    (a, b) =>
      String(b.submitted_at ?? "").localeCompare(String(a.submitted_at ?? "")) ||
      String(a.recipient_email ?? "").localeCompare(String(b.recipient_email ?? ""))
  );

  if (completions.length === 0) {
    drawParagraph(ctx, "No completions recorded yet.", { muted: true });
  }

  for (const completion of completions) {
    const recipientName = completion.recipient_name?.trim() || completion.recipient_email?.trim() || "Recipient";
    const recipientSecondary =
      completion.recipient_name && completion.recipient_email ? completion.recipient_email : null;
    const engagementValue = `Scroll ${fmtScroll(completion.max_scroll_percent)} | Active ${fmtDuration(
      completion.active_seconds
    )} | Time on page ${fmtDuration(completion.time_on_page_seconds)}`;

    const openingRowsHeight =
      estimateKeyValueHeight(ctx, "Status", completion.acknowledged ? "Acknowledged" : "Not acknowledged") +
      estimateKeyValueHeight(ctx, "Submitted", fmtUtc(completion.submitted_at)) +
      estimateKeyValueHeight(ctx, "Engagement", engagementValue);
    ctx.ensureSpace(openingRowsHeight + 28);

    drawSectionHeading(ctx, recipientName, recipientSecondary ?? undefined);
    drawKeyValueRow(ctx, "Status", completion.acknowledged ? "Acknowledged" : "Not acknowledged");
    drawKeyValueRow(ctx, "Submitted", fmtUtc(completion.submitted_at));
    drawKeyValueRow(ctx, "Engagement", engagementValue);
    drawKeyValueRow(ctx, "IP address", completion.ip ?? "--", { valueFont: "mono" });
    drawKeyValueRow(ctx, "User agent", completion.user_agent ?? "--");
    ctx.cursor.y -= 7;
  }

  finalizeFooters(ctx, "Receipt Evidence Document", {
    poweredByBrand: "Receipt",
    poweredByLogo: receiptLogo,
  });
  ctx.pdf.setTitle("Receipt Evidence Record");
  ctx.pdf.setProducer("Receipt");
  ctx.pdf.setCreator("Receipt");
  ctx.pdf.setCreationDate(metadataDate);
  ctx.pdf.setModificationDate(metadataDate);
  return saveReport(ctx, process.env.PDF_DETERMINISTIC === "1");
}
